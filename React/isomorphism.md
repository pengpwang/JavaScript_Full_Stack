
### 一、H5同构项目目标：
1. 首要目标：
  性能上
- SSR同构引入后，首屏DOMContentLoaded时间及Load时间得到降低；首屏渲染得到提升
2. 其他目标
  项目架构及代码上
- 同时支持SSR以及CSR两种开发模式,本地开发环境以及线上环境皆可无缝切换两种渲染模式
- 统一前端路由与服务端路由，无需重复编写路由文件配置
- 最大限度降低现有组件改造成本
 业务开发
- 支持本地开发HMR


### 二、如何搭建一个同构应用的开发环境？
至少有以下问题需要处理：
1. Nodejs环境如何加载前端组件
  - Nodejs环境不支持ES Module，不支持jsx ==> babel, webpack 打包编译
  - 只打包前端组件，不打包nodejs代码 ==> 原因：a. 引入babel会导致需加载的模块数量巨大； b. 绝大多数语法自node8已原生支持，除非静态分析用ts，否则编译服务端文件意义不大； c. 编译后的代码不可读，debug困难
  - webpack的Nodejs服务端配置 ==> a. target; b. 开发环境开启source-map; c. externals选项排除nodejs服务端代码(nodejs内置包，三方包)
  - 打包编译文件存放于内存还是本地磁盘？ ==> 存放于内存的劣势：a. 读取麻烦，需要⽤到memory-fs，同时涉及到进程通信; b. loadable路由分割场景处理麻烦还是得落地磁盘; c. 开启externals后⽂件⼤小⼤多在几十kb之内，对⽐存放内存中速度优势并不明显
2. 组件的数据如何获取
  - 无法放在componentWillMount  ==> 原因：a. 异步请求无法在render方法调⽤之前取得结果; b. 客户端会重复获取数据
  - 定义静态方法loadData获取 ==> a. 服务端根据ctx.path获取请求的具体组件(涉及多级路由匹配)，统一并发调用各组件获取数据的静态方法; b. 在客户端切换路由时，如何调用静态方法loadData(目前有以下方式：按组件统一范式封装，在componentDidMount生命周期钩子依各组件情况个性化调用；Next.js 通过大量改造react-router,封装了一套自己的router,监听路由跳转动作；封装一个React HOC，包装所有有客户端及服务端获取数据需求的组件) ==> **此步骤存在改造成本**
3. HMR 怎么做
  - webpack-dev-server
4. CSS如何处理
  - style-loader ==> 不支持服务端渲染
  目前两种方式处理：
  - isomorphic-style-loader ==> 支持服务端渲染，但对代码入侵性较强，需要手动收集样式依赖；
  - css-hot-loader ==> 统一开发/生产环境渲染方式，配置简单；但引入后改变了之前style-loader以style标签inject到文档中的渲染模式；
5. 如何拼接成完整的html结构返回
  (1).响应返回：目前有两种方式
   a. 通过renderToString返回string  ==> 一次性处理完成后才开始向浏览器返回结果，性能较低
   b. 通过renderToNodeStream返回Readable stream 字节流 ==> 服务端处理内容时是实时向浏览器端传输数据, 有利于页面的初始加载速度和首屏展现时间
  (2).html结构模板：目前有三种方式
   a. html文件  ==> 灵活性差
   b. 模板引擎   ==> 需熟悉特定语法；调试麻烦；可读性也差
   c. JSX      ==> 无需引入三方库；功能全覆盖；编辑器错误提示友好；支持HMR；支持TS，即可用TSX
6. 双端渲染结果不一致怎么办
  本质原因：服务端与客户端差异及代码编写差异
  如：h5项目中引入的动画库(涉及DOM操作，如：找DOM添加class等)，只能在浏览器端渲染
  解决方式，如下两种：
  - 通过环境常量判断：如__isBrowser__和__isServer__
  - 通过封装只在客户端渲染的React HOC，包装客户端渲染组件
7. 如何进行路由分割
  - react-loadable 官方ssr处理方案
  - react-loadable-ssr-addon 的ssr处理
  - 服务端的bundle无需分块，webpack开启externals选项，bundle比较小，分块带来的性能收益与配置复杂度相比可以忽略不计
8. 如何降级为客户端渲染
  (1). 服务端渲染与客户端渲染的流程差异
   a. 服务端渲染：服务端获取数据，渲染完整页面，加载js，注水绑定事件
   b. 客户端渲染：html空骨架，加载js，客户端获取数据，客户端渲染页面，绑定事件
  按此流程，服务端渲染降级为客户端渲染，只需nodejs ssr服务器端返回html空骨架即可(与nginx关系？待验证)
  (2). 降级方式：
   a. 通过ssr 服务器端配置(可全局降级，也可对特定页面使用ssr)
   b. 通过querystring参数 csr=true 降级
9. 生产环境如何发布应用
  保证nodejs ssr服务器启动资源和CDN资源同步

### 三、h5项目React同构改造方案基建
#### (一)、目录结构调整：
1. 服务端运行的代码与客户端运行的代码的差异化区分抽离(`/src/server`, `/src/client`)及共性抽离(`/src/shared`)
 - `/client`负责浏览器端的渲染
 - `/server`负责服务端的逻辑，主要包括响应页面请求、服务端渲染等
 - `/shared`为两端同构部分，包括构成页面的所有组件、组件依赖的样式文件以及静态资源等
目的：维护性；构建编译的前提

#### (二)、构建：
1. 模块化标准统一到es module  -- 针对服务端
2. es6，jsx，tsx编译；less，sass，postcss编译
3. 服务端构建及客户端构建；两端构建的共性及差异性
4. webpack配置优化 - 主要为客户端配置优化
5. npm script 构建流 - 包括本地开发构建流，生产构建
  a. dev - 本地开发环境启动，包括保存后同步编译客户端运行代码【内存中，缓存构建】，服务端运行代码【落磁盘】，启动服务端nodejs渲染服务器 ==》构建速度需优化 ✨
  b. build - 打包服务端以及客户端资源文件
  c. start - 生产代码构建后，start启动nodejs渲染服务器  --- 生产环境启动方式
  d. analyze - 可视化分析客户端打包的资源详情 --- 用于分析构建打包产出
  d. 构建速度优化 -- 是否需要引入底层以Rust/Go为内核的构建工具提高编译打包速度？

#### (三)、服务端React与客户端React
1. 服务端通过renderToString将虚拟DOM渲染成字符串；或通过renderToNodeStream返回Readable stream 字节流
2. 客户端通过ReactDOM.hydrate水合服务端html
3. 服务端无法执行事件绑定，客户端执行js，绑定事件
4. 服务端无法执行`componentDidMount`，原客户端此生命周期内获取数据的方法需抽取出，构造组件级静态方法`loadData`用于服务端数据获取；若服务端注入此组件数据，客户端`componentDidMount`无需再次获取对应数据
5. 对于组件，同时适用于客户端及服务端的改造；

#### (四)、路由机制：
1. 浏览器端使用BrowerRouter, 服务器端使用StaticRouter
2. 路由配置及多级路由配置 - 对象配置 - 是否其他改造较小的方式？
3. 服务器端路由匹配及多级路由匹配；借助于 `react-router-config`的`matchRoutes`
4. 浏览器端及服务器端的路由渲染及多级路由渲染；借助于 `react-router-config`的`renderRoutes`
5. 未登录时，服务端redirect到登录页，客户端登录后直接进入未登录前的请求页 301重定向
6. 404页面，服务端返回404页面及404状态码

#### (五)、数据流：
1. 数据请求库 - 支持客户端及服务器端
2. 服务器端请求与客户端请求的不同处理 -- 客户端请求域名及服务端请求域名的差异/服务端请求携带其他额外http链路参数
3. 中间层数据请求代理
4. 服务端部分接口请求失败的处理  -- a.页面组件渲染;b.接入日志追踪系统
5. 服务端及客户端数据流管理的统一 -- redux
  a. 服务端store的创建
  b. 客户端store的创建(需脱水服务端注入的数据，用于客户端store的初始化)
6. 服务端数据获取的时机及组件级静态方法`loadData`的执行时机
7. 数据同步策略 -- 服务端渲染用到的数据在客户端重用 -- 数据的注水及脱水

#### (六)、css样式
1. 服务器端使用isomorphic-style-loader，浏览器端使用style-loader；或统一使用css-hot-loader
2. 使用isomorphic-style-loader时需React高阶组件封装 - 组件样式生成
3. 服务端css样式组装及注入 -- 客户端js是否重新驱动覆盖首屏内嵌style？

#### (七)、服务端缓存：
1. 与用户无关的接口和页面的缓存  -- 降低内容到达时间
2. React组件级缓存
3. 各缓存方案的选取？

#### (八)、SSR降级机制：
目标：CSR/SSR两种渲染模式无缝切换一键降级  ==》 一键切换，http://xxx.com?csr=true  ==》CSR
1. SSR应用降级至SPA应用的时机？
  a. 服务端渲染流程中发生某些异常或全部异常？
  b. 大流量场景减少服务器负担
2. 降级机制包括：
  a. URL或配置文件中的全局降级；或者配置文件中指定路由的降级
  b. 服务器端渲染流程中发生异常

#### (九)、接入全链路追踪：
1. 服务端接口请求报错日志记录
2. 渲染服务器渲染报错日志记录

#### (十)、性能优化：
1. Static Generation v.s. Server-side Rendering
2. nodejs渲染服务器缓存：
 a. 页面缓存
 b. React组件级缓存 
 c. 特定接口数据缓存

#### (十一)、部署：
1. 静态资源(js, css, images, fonts 及 Static Generation)部署 -- CDN部署
2. Server-side Rendering 部署 -- nodejs渲染服务器部署
3. 降级为单页SPA时，提供的web应用容器外层是否nginx，或单页SPA由nodejs渲染服务器提供静态资源服务功能

#### (十二)、h5项目ssr注意事项：
1. 环境区分 - 服务端还是客户端
2. 埋点的处理
3. 用户登录状态转发
4. 动画库的处理
...其他问题...
其他问题：
1. nodejs SSR渲染服务器是否提供静态资源服务器功能
2. nodejs SSR渲染服务器是否提供数据代理转发功能，以优化数据调用链路
  - 如果提供数据代理转发功能，什么情况下代理？ -- 请求path？_mt区分？
  - 不提供数据代理，渲染服务器请求网关与浏览器端请求网关 - 同步？渲染服务器直接转发浏览器验签参数或渲染服务器实现浏览器验签功能
...其他...




